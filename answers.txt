Теоретический вопрос 1:
Почему же датасеты меняют инженерные решения? Почему алгоритм со 100
элементами может оказаться совершенно неэффективным со 100 000 элементов?
Это связано с тем, как сколько шагов приходится на проверку даты.

Представим у нас есть большой список из случайных элементов, нам нужен
один конкретный элемент. Даже если в этом списке есть дубликаты, программа бездумно
пройдет через весь список и проверит каждый элемент, прежде найти(или не найти)
нужный элемент. 

Хеш функция не только распределит элементы по порядку, но и исключит
из них дубликаты, так что поиск и заполнение множества придется гораздо быстрее чем 
со списком. Но и этот алгоритм станет ненужным, если нам вдруг понадобятся все дубликаты,
нам нужен будет алгоритм который будет сортировать элементы по их признакам
Именно поэтому здесь важно подобрать свой механизм, который будет более эффективен
чем предыдущий


Теоретический вопрос 2:

Что такое доминантный член, почему он так важен?
Доминантный член показывает насколько быстро меняется функция
в зависимости от числа элементов n, причем доминантный член
будет расти гораздо быстрее чем все остальные, поэтому в первую очередь
мы будем обращать внимание на него.

Возьмем функцию 5n^2 + 100n + 1000. Здесь первый член будет доминантным,
Потому что он мало того что умножается на 5, так еще и возводится во вторую
степень. Поэтому при росте n он будет значительно больше чем 100n и особенно 1000
давайте проверим на практике(код к нему в solution.py): 

==================================================
Доминатное слагаемое 5n^2. При 100 элементов время: 0.006159с | шагов: 50000 (Конт. вопрос 2) |
Среднее слагаемое 100n. При 100 элементов время: 0.001656с | шагов: 10000 (Конт. вопрос 2) |
Cвободное слагаемое 1000. При 100 элементов время: 0.000231с | шагов: 1000 (Конт. вопрос 2) |

РЕЗУЛЬТАТЫ. Функция вида 5n^2 + 100n + 1000 | всего шагов: 61000 | всего времени затрачено: 0.008046с 
==================================================

Теоретический вопрос 3:

Сравнение функций роста.
Даны функции f(n) = n, g(n) = n^2 и h(n) = log(n)
При n = 1_000_000 нужно вычислить приблизительное значение
и расположить в порядке возрастания

==================================================
Результат f(n) = n, при n = 10000000: 0.092488c|
Алгоритм находит выбранный элемент из списка со случайными числами ЛИНЕЙНО

Результат f(n) = log(n), при n = 10000000: 0.481879c|
Алгоритм находит выбранный элемент из списка со случайными числами БИНАРНЫМ способом

Результат f(n) = n^2, при n = 10000000: 5.279458c|
Алгоритм определяет есть ли в списке дубликаты НАИВНЫМ способом
==================================================
РЕЗУЛЬТАТЫ: из трех алгоритмов самым быстрым можно назвать n, а самым 
медленным n^2